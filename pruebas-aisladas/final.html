<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ruta Óptima de Producción - Deck Heroes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #e0e1e6;
      color: #222;
      margin: 0;
      padding: 0;
    }
    .container {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.08);
      width: 95vw;
      max-width: 900px;
      margin: 32px auto 0 auto;
      padding: 32px 18px 32px 18px;
    }
    h1 {
      text-align: center;
      color: #1e3a8a;
      margin-bottom: 8px;
    }
    .desc {
      text-align: center;
      color: #555;
      margin-bottom: 28px;
      font-size: 1.08em;
    }
    .panel {
      background: #f5f6fa;
      border-radius: 8px;
      padding: 18px 14px;
      margin-bottom: 18px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.04);
    }
    .panel-title {
      font-weight: bold;
      color: #1e3a8a;
      margin-bottom: 8px;
      font-size: 1.1em;
    }
    .ruta-optima, .cronograma {
      min-height: 60px;
      color: #333;
      font-size: 1.08em;
    }
    .controles {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 18px;
    }
    .controles > * {
      font-size: 1em;
      padding: 8px 16px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #f5f6fa;
      color: #222;
      transition: background 0.2s;
      cursor: pointer;
    }
    .controles > *:hover {
      background: #e0e1e6;
    }
    @media (max-width: 600px) {
      .container { padding: 12px 2vw; }
      .panel { padding: 10px 4px; }
    }
    .simulacion-grid {
      display: grid;
      grid-template-columns: 3fr 2fr;
      gap: 24px;
      width: 90vw;
      max-width: 1200px;
      margin: 0 auto 32px auto;
      align-items: flex-start;
    }
    .simulacion-col {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      padding: 18px 14px 18px 14px;
      min-height: 320px;
    }
    .tabla-pasos {
      width: 100%;
      border-collapse: collapse;
      font-size: 1em;
      margin-bottom: 12px;
    }
    .tabla-pasos th, .tabla-pasos td {
      border: 1px solid #bbb;
      padding: 6px 8px;
      text-align: center;
    }
    .tabla-pasos th {
      background: #e0e1e6;
      color: #222;
    }
    .tabla-pasos tr:nth-child(even) {
      background: #f5f6fa;
    }
    .sugerencias-auto {
      margin-top: 10px;
      color: #1976d2;
      font-size: 1.01em;
    }
    .inventario-final-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.98em;
    }
    .inventario-final-table th, .inventario-final-table td {
      border: 1px solid #bbb;
      padding: 5px 7px;
      text-align: center;
    }
    .inventario-final-table th {
      background: #e0e1e6;
      color: #222;
    }
    .inventario-final-table tr:nth-child(even) {
      background: #f5f6fa;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Ruta Óptima de Producción</h1>
    <div class="desc">
      Aquí podrás ver la mejor secuencia de pasos para fabricar tu equipo, optimizando materiales y tiempo.<br>
      Próximamente: simulador interactivo, cronograma y sugerencias inteligentes.
    </div>
    <div class="controles">
      <!-- Aquí irán los controles para seleccionar objetivo, cargar inventario, etc. -->
      <button disabled>Seleccionar objetivo</button>
      <button disabled>Cargar inventario</button>
      <button disabled>Simular ruta óptima</button>
    </div>
    <div style="display:flex;justify-content:flex-end;margin-bottom:10px;">
      <button id="btn-cargar-datos" style="background:#888;color:#fff;padding:7px 18px;border:none;border-radius:6px;cursor:pointer;font-size:1em;">Cargar datos</button>
      <input type="file" id="file-recetas" accept=".json,application/json" style="display:none;">
      <input type="file" id="file-materiales" accept=".json,application/json" style="display:none;">
    </div>
    <div style="margin:18px 0 8px 0;">
      <label style="font-weight:normal;cursor:pointer;"><input type="checkbox" id="chk-desmantelar" style="margin-right:6px;">Considerar desmantelado de equipos dorados de nivel 1</label>
    </div>
    <div id="simulacion-columna-unica">
      <div style="font-weight:bold;font-size:1.12em;margin-bottom:8px;">Pasos de simulación</div>
      <table class="tabla-pasos">
        <thead>
          <tr>
            <th>Paso</th>
            <th>Descripción</th>
            <th>Materiales usados</th>
          </tr>
        </thead>
        <tbody class="tbody-pasos">
          <!-- Aquí se llenarán los pasos de la simulación -->
        </tbody>
      </table>
      <div class="sugerencias-auto"></div>
      <div class="ruta-optima"></div>
      <div class="cronograma"></div>
      <div class="advertencias"></div>
      <div style="font-weight:bold;font-size:1.12em;margin:18px 0 8px 0;">Inventario final tras la simulación</div>
      <table class="inventario-final-table">
        <thead>
          <tr>
            <th>Material</th>
            <th>Dorado</th>
            <th>Morado</th>
            <th>Azul</th>
            <th>Verde</th>
            <th>Blanco</th>
          </tr>
        </thead>
        <tbody class="tbody-inventario-final">
          <!-- Aquí se llenará el inventario final -->
        </tbody>
      </table>
    </div>
  </div>
  <!-- Toast notification -->
  <div id="toast" style="display:none;"></div>
  <script type="module">
  import { cargarRecetasPersonalizadas, inicializarAlmacenamientoMateriales } from '../scripts/materiales.js';
  import { datosMateriales, mapaColores, nivelesPorClase, coloresPorClase } from '../scripts/datos.js';

  // Estado global simple
  const estado = {
    materialesData: datosMateriales,
    almacenMateriales: {},
    recetas: [],
    recetaFinalIndex: '',
    filtros: {
      clase: '',
      equipo: '',
      color: '',
      nivel: ''
    },
    seleccionBaseAlternativa: '', // equipo base alternativo elegido
    seleccionColorBase: '', // color de base elegido en bifurcación
  };

  // Cargar recetas y materiales automáticamente si existen
  function cargarDatosUsuario() {
    let recetasCargadas = false;
    try {
      const r = cargarRecetasPersonalizadas();
      if (r && Object.keys(r).length > 0) {
        estado.recetas = r;
        recetasCargadas = true;
      }
    } catch {}
    if (!recetasCargadas) {
      inicializarAlmacenamientoMateriales(estado);
      estado.recetas = cargarRecetasPersonalizadas();
    }
  }
  cargarDatosUsuario();

  function getRecetasFiltradas() {
    return Object.keys(estado.recetas).filter(k => {
      const r = estado.recetas[k];
      if (estado.filtros.clase && r.clase !== estado.filtros.clase) return false;
      if (estado.filtros.equipo && r.equipo !== estado.filtros.equipo) return false;
      if (estado.filtros.color && r.color !== estado.filtros.color) return false;
      if (estado.filtros.nivel && r.nivel !== estado.filtros.nivel) return false;
      return ['Campeón','Planewalker','Lord','Noble Lord'].includes(r.clase);
    });
  }

  function formatearNombreReceta(r) {
    if (!r || typeof r !== 'object') return '';
    const clase = r.clase || '';
    const color = r.color ? (r.color.charAt(0).toUpperCase() + r.color.slice(1)) : '';
    const equipo = r.equipo || '';
    const nivel = r.nivel || '';
    let base = '-';
    if (r.base && typeof r.base === 'object') {
      base = (r.base.clase || '') + ' ' + (r.base.nivel || '') + ' ' + (r.base.color || '');
    }
    return `${clase} ${color} (${equipo}, Nivel ${nivel}, Base: ${base})`;
  }

  function renderControles() {
    const controles = document.querySelector('.controles');
    controles.innerHTML = '';
    // Solo mostrar controles si hay recetas y materiales cargados
    if (!Array.isArray(estado.recetas) || estado.recetas.length === 0 || !estado.almacenMateriales || Object.keys(estado.almacenMateriales).length === 0) {
      // No mostrar nada
      return;
    }
    // Escoger equipo (solo los 6 válidos)
    const equiposValidos = ['espada','pecho','botas','casco','guantes','cinturón'];
    const selectEquipo = document.createElement('select');
    selectEquipo.style.minWidth = '120px';
    selectEquipo.innerHTML = '<option value="">Escoger equipo...</option>';
    equiposValidos.forEach(eq => {
      const opt = document.createElement('option');
      opt.value = eq;
      opt.textContent = eq.charAt(0).toUpperCase() + eq.slice(1);
      if (eq === estado.filtros.equipo) opt.selected = true;
      selectEquipo.appendChild(opt);
    });
    selectEquipo.onchange = e => { estado.filtros.equipo = e.target.value; renderControles(); };
    controles.appendChild(selectEquipo);
    // Selector de receta final (mostrar tal cual se han cargado)
    const selectReceta = document.createElement('select');
    selectReceta.style.minWidth = '220px';
    selectReceta.innerHTML = '<option value="">Selecciona receta final...</option>';
    estado.recetas.forEach((r, idx) => {
      const opt = document.createElement('option');
      opt.value = idx;
      opt.textContent = formatearNombreReceta(r);
      if (String(idx) === String(estado.recetaFinalIndex)) opt.selected = true;
      selectReceta.appendChild(opt);
    });
    selectReceta.onchange = e => {
      const val = e.target.value;
      if (val === '' || isNaN(val) || !estado.recetas[parseInt(val)]) {
        estado.recetaFinalIndex = '';
        showToast('Selecciona una receta final válida.','error');
        return;
      }
      estado.recetaFinalIndex = val;
    };
    controles.appendChild(selectReceta);
    // Botón simular ruta óptima
    const btnSimular = document.createElement('button');
    btnSimular.textContent = 'Simular ruta óptima';
    btnSimular.style.marginLeft = '16px';
    btnSimular.style.padding = '7px 18px';
    btnSimular.style.fontSize = '1em';
    btnSimular.style.background = '#1976d2';
    btnSimular.style.color = '#fff';
    btnSimular.style.border = 'none';
    btnSimular.style.borderRadius = '6px';
    btnSimular.style.cursor = 'pointer';
    btnSimular.onclick = () => simularRutaOptima();
    controles.appendChild(btnSimular);
  }

  function renderInventarioFinal() {
    // Mostrar el inventario actual cargado, no el de la simulación
    let html = '';
    Object.keys(estado.almacenMateriales).forEach(key => {
      const mat = key.split(':')[1];
      html += `<tr><td>${mat}</td>`;
      ['dorado','morado','azul','verde','blanco'].forEach(c => {
        html += `<td>${estado.almacenMateriales[key][c] ? estado.almacenMateriales[key][c] : 0}</td>`;
      });
      html += '</tr>';
    });
    return html;
  }

  function calcularRutaYTiempo(recetaKey) {
    if (!recetaKey || !estado.recetas[recetaKey]) return { pasos: [], tiempoTotal: 0, advertencias: ['Selecciona una receta final válida.'] };
    const recetaFinal = estado.recetas[recetaKey];
    let pasos = [];
    let advertencias = [];
    let tiempoTotal = 0;
    let secuencia = [];
    // 1. Recetas normales de nivel 1 (blanco, luego morado, luego dorado)
    for (const color of ['blanco','morado','dorado']) {
      const k = Object.keys(estado.recetas).find(k => {
        const r = estado.recetas[k];
        return r.clase === 'Normal' && r.nivel === '1' && r.color === color && r.equipo === recetaFinal.equipo;
      });
      if (k) secuencia.push(k);
      else advertencias.push(`Falta receta: Normal 1 ${color}`);
    }
    // 2. Niveles 2, 3, 4 (dorado)
    for (let n = 2; n <= 4; n++) {
      const k = Object.keys(estado.recetas).find(k => {
        const r = estado.recetas[k];
        return r.clase === 'Normal' && r.nivel === String(n) && r.color === 'dorado' && r.equipo === recetaFinal.equipo;
      });
      if (k) secuencia.push(k);
      else advertencias.push(`Falta receta: Normal ${n} dorado`);
    }
    // 3. Lógica de base según clase avanzada
    let baseMsg = '';
    if (recetaFinal.clase === 'Planewalker') {
      // Base: equipo Normal de nivel 5 y del mismo tipo
      baseMsg = `Base requerida: ${recetaFinal.equipo} Normal nivel 5 (cualquier color)`;
      const k = Object.keys(estado.recetas).find(k => {
        const r = estado.recetas[k];
        return r.clase === 'Normal' && r.nivel === '5' && r.equipo === recetaFinal.equipo;
      });
      if (k) secuencia.push(k);
      else advertencias.push(`Falta receta base: Normal 5 (${recetaFinal.equipo})`);
    } else if (recetaFinal.clase === 'Lord') {
      // Base: equipo Normal de nivel 5, cualquier tipo
      baseMsg = `Base requerida: cualquier equipo Normal nivel 5 (cualquier color)`;
      const k = Object.keys(estado.recetas).find(k => {
        const r = estado.recetas[k];
        return r.clase === 'Normal' && r.nivel === '5';
      });
      if (!k) advertencias.push(`Falta receta base: Normal 5 (cualquier equipo)`);
    } else if (recetaFinal.clase === 'Noble Lord') {
      // Base: equipo Lord de nivel 5, cualquier tipo
      baseMsg = `Base requerida: cualquier equipo Lord nivel 5 (cualquier color)`;
      const k = Object.keys(estado.recetas).find(k => {
        const r = estado.recetas[k];
        return r.clase === 'Lord' && r.nivel === '5';
      });
      if (!k) advertencias.push(`Falta receta base: Lord 5 (cualquier equipo)`);
    } else if (recetaFinal.clase === 'Campeón') {
      // Base: equipo Normal de nivel 4 y mismo tipo
      baseMsg = `Base requerida: ${recetaFinal.equipo} Normal nivel 4 (cualquier color)`;
      const k = Object.keys(estado.recetas).find(k => {
        const r = estado.recetas[k];
        return r.clase === 'Normal' && r.nivel === '4' && r.equipo === recetaFinal.equipo;
      });
      if (!k) advertencias.push(`Falta receta base: Normal 4 (${recetaFinal.equipo})`);
    }
    // 4. Receta final
    secuencia.push(recetaKey);
    // Procesar cada paso
    for (const k of secuencia) {
      const r = estado.recetas[k];
      if (!r) continue;
      const tiempos = { dorado: 512, morado: 128, azul: 32, verde: 8, blanco: 2 };
      let tiempo = 0;
      Object.entries(r.materiales).forEach(([col, cant]) => {
        tiempo += (tiempos[col] || 0) * (cant || 0);
      });
      tiempoTotal += tiempo;
      pasos.push({
        nombre: formatearNombreReceta(r),
        materiales: r.materiales,
        tiempo,
        tasaExito: r.tasaExito || r.porcentaje || 100
      });
    }
    return { pasos, tiempoTotal, advertencias, baseMsg };
  }

  function formatearTiempo(horas) {
    if (!horas || isNaN(horas)) return '0h';
    const meses = Math.floor(horas / (30*24));
    let resto = horas % (30*24);
    const semanas = Math.floor(resto / (7*24));
    resto = resto % (7*24);
    const dias = Math.floor(resto / 24);
    const h = resto % 24;
    let partes = [];
    if (meses) partes.push(`${meses} mes${meses>1?'es':''}`);
    if (semanas) partes.push(`${semanas} semana${semanas>1?'s':''}`);
    if (dias) partes.push(`${dias} día${dias>1?'s':''}`);
    if (h) partes.push(`${h} h`);
    return partes.join(', ') || '0h';
  }

  function renderDesmantelado() {
    // Solo implementado para equipo dorado de nivel 1
    // Tiempo fabricar equipo dorado de nivel 1: 388h
    // Tiempo fabricar 1 material dorado desde cero: 512h
    // Ahorro: 124h
    let html = `<b>Desmantelado de equipo dorado de nivel 1</b><br>`;
    html += `Si fabricas un equipo dorado de nivel 1 (<b>388h</b>) y lo desmantelas, obtienes 1 material dorado al azar (de los 2 usados en la receta).<br>`;
    html += `Si el material obtenido es el que necesitas, <b>te ahorras 124 horas</b> respecto a fabricarlo desde cero (<b>512h</b>).`;
    html += `<br><span style='color:#888;font-size:0.98em;'>(Esta mecánica puede cambiar para otros niveles. Por ahora, solo está confirmada para nivel 1. Para nivel 5, se cree que da 2 materiales, pero no está confirmado.)</span>`;
    document.querySelector('.desmantelado').innerHTML = html;
  }

  function simularPasos(recetaFinal, inventarioOriginal) {
    if (!recetaFinal) return { pasos: [], inventarioFinal: {}, sugerencias: ['Selecciona una receta final válida.'], cronograma: [] };
    // Copia profunda del inventario
    let inventario = JSON.parse(JSON.stringify(inventarioOriginal));
    let pasos = [];
    let sugerencias = [];
    let pasoNum = 1;
    let cronograma = [];
    let tiempoTotal = 0;
    // Helper para descontar materiales del inventario
    function descontarMateriales(materiales) {
      let faltantes = {};
      for (const color in materiales) {
        let req = materiales[color];
        if (!req) continue;
        let disp = inventario[color] || 0;
        if (disp >= req) {
          inventario[color] -= req;
          req = 0;
        } else {
          inventario[color] = 0;
          req -= disp;
        }
        if (req > 0) faltantes[color] = req;
      }
      return faltantes;
    }
    // 1. Procesar materiales de la receta final
    Object.entries(recetaFinal.materiales).forEach(([color, cantidad]) => {
      if (cantidad > 0) {
        let usado = Math.min(inventario[color] || 0, cantidad);
        if (usado > 0) {
          pasos.push({
            paso: pasoNum++,
            accion: `Usar ${usado} ${recetaFinal.equipo} en ${color}`,
            color,
            cantidad: usado,
            faltante: 0
          });
          inventario[color] -= usado;
        }
        let faltan = cantidad - usado;
        if (faltan > 0) {
          pasos.push({
            paso: pasoNum++,
            accion: `Falta ${faltan} ${recetaFinal.equipo} en ${color}`,
            color,
            cantidad: 0,
            faltante: faltan
          });
        }
      }
    });
    // 2. Sugerencias automáticas
    if (pasos.length && pasos[0].materiales && pasos[0].materiales.includes('0')) {
      sugerencias.push('Puedes saltar los primeros pasos usando materiales de tu inventario.');
    }
    // Si falta algún material al final
    for (const color of ['dorado','morado','azul','verde','blanco']) {
      if ((inventario[color]||0) < 0) {
        sugerencias.push(`Te falta ${-inventario[color]} ${color}${-inventario[color]>1?'s':''} para completar la simulación.`);
      }
    }
    // Para cada paso, estimar tiempo (ejemplo: dorado=512h, morado=128h, azul=32h, verde=8h, blanco=2h)
    pasos.forEach(p => {
      let tiempo = 0;
      if (p.color) {
        if (p.color === 'dorado') tiempo = 512 * (p.cantidad || p.faltante || 1);
        else if (p.color === 'morado') tiempo = 128 * (p.cantidad || p.faltante || 1);
        else if (p.color === 'azul') tiempo = 32 * (p.cantidad || p.faltante || 1);
        else if (p.color === 'verde') tiempo = 8 * (p.cantidad || p.faltante || 1);
        else if (p.color === 'blanco') tiempo = 2 * (p.cantidad || p.faltante || 1);
      }
      tiempoTotal += tiempo;
      cronograma.push({ paso: p.paso, accion: p.accion, color: p.color, tiempo });
    });
    // Ejemplo para equipo base alternativo:
    let equiposDisponibles = ['espada','botas','casco','cinturón']; // <- esto debe calcularse según inventario
    if (equiposDisponibles.length > 1) {
      pasos.push({
        paso: pasoNum++,
        accion: 'Selecciona equipo base alternativo:',
        selectEquipo: true,
        opciones: equiposDisponibles,
        seleccionado: estado.seleccionBaseAlternativa || equiposDisponibles[0]
      });
    }
    // Ejemplo para bifurcación de color:
    let coloresBase = ['morado','dorado'];
    pasos.push({
      paso: pasoNum++,
      accion: '¿Qué color obtuviste en la base?',
      selectColor: true,
      opciones: coloresBase,
      seleccionado: estado.seleccionColorBase || coloresBase[0]
    });
    return { pasos, inventarioFinal: inventario, sugerencias, cronograma, tiempoTotal };
  }

  // === SIMULACIÓN DE RUTA ÓPTIMA UNIVERSAL POR EQUIPO ===
  function simularRutaOptima() {
    try {
      if (!estado.recetaFinalIndex || estado.recetaFinalIndex === '') {
        showToast('Selecciona una receta final válida.','error');
        return;
      }
      const recetaFinal = estado.recetas[parseInt(estado.recetaFinalIndex)];
      if (!recetaFinal) {
        showToast('Receta final no encontrada.','error');
        return;
      }
      
      // Limpiar arrays
      rutas = [];
      advertencias = [];
      
      // Obtener materiales del equipo seleccionado
      const equipo = recetaFinal.equipo;
      const materialesEquipo = estado.materialesData[recetaFinal.clase]?.[equipo] || estado.materialesData['Normal']?.[equipo] || [];
      
      // Copia profunda del inventario
      let inventario = JSON.parse(JSON.stringify(estado.almacenMateriales));
      
      // Simular la fabricación completa paso a paso
      let pasosCompletos = [];
      let tiempoTotal = 0;
      
      // Si es una clase avanzada, fabricar primero las bases necesarias
      if (recetaFinal.clase === 'Campeón') {
        // Campeón requiere equipo normal nivel 4 como base
        const recetaBase = buscarReceta('Normal', '4', 'dorado', equipo);
        if (recetaBase) {
          const resultadoBase = fabricarRecursivo(recetaBase, inventario, [], 0, []);
          if (resultadoBase && resultadoBase.ruta) {
            pasosCompletos = pasosCompletos.concat(resultadoBase.ruta);
            inventario = resultadoBase.inventario;
            tiempoTotal += resultadoBase.tiempo;
          }
        }
      } else if (recetaFinal.clase === 'Planewalker') {
        // Planewalker requiere equipo normal nivel 5 como base
        const recetaBase = buscarReceta('Normal', '5', 'dorado', equipo);
        if (recetaBase) {
          const resultadoBase = fabricarRecursivo(recetaBase, inventario, [], 0, []);
          if (resultadoBase && resultadoBase.ruta) {
            pasosCompletos = pasosCompletos.concat(resultadoBase.ruta);
            inventario = resultadoBase.inventario;
            tiempoTotal += resultadoBase.tiempo;
          }
        }
      } else if (recetaFinal.clase === 'Lord' || recetaFinal.clase === 'Noble Lord') {
        // Lord/Noble Lord requieren equipo normal nivel 5 como base
        const recetaBase = buscarReceta('Normal', '5', 'dorado', equipo);
        if (recetaBase) {
          const resultadoBase = fabricarRecursivo(recetaBase, inventario, [], 0, []);
          if (resultadoBase && resultadoBase.ruta) {
            pasosCompletos = pasosCompletos.concat(resultadoBase.ruta);
            inventario = resultadoBase.inventario;
            tiempoTotal += resultadoBase.tiempo;
          }
        }
      }
      
      // Ahora fabricar el equipo final
      const resultadoFinal = fabricarRecursivo(recetaFinal, inventario, [], tiempoTotal, []);
      if (resultadoFinal && resultadoFinal.ruta) {
        pasosCompletos = pasosCompletos.concat(resultadoFinal.ruta);
        tiempoTotal = resultadoFinal.tiempo;
      }
      
      // Mostrar resultados
      const tbody = document.querySelector('.tbody-pasos');
      tbody.innerHTML = '';
      
      if (pasosCompletos.length === 0) {
        showToast('No se pudo simular la ruta. Verifica que existan materiales y recetas suficientes.','error');
        document.querySelector('.advertencias').innerHTML = '<b>Advertencia:</b> No se pudo simular la ruta. Verifica que existan materiales y recetas suficientes.';
        return;
      }
      
      // Renderizar todos los pasos
      pasosCompletos.forEach((p, idx) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${idx + 1}</td><td>${p.descripcion || ''}</td><td>${(p.materiales && p.materiales.length) ? p.materiales.join(', ') : ''}</td>`;
        tbody.appendChild(tr);
      });
      
      // Inventario final
      const tbodyInv = document.querySelector('.tbody-inventario-final');
      tbodyInv.innerHTML = renderInventarioFinal();
      
      // Advertencias
      document.querySelector('.advertencias').innerHTML = advertencias.length ? '<b>Advertencias:</b><br>' + advertencias.join('<br>') : '';
      
      // Mostrar tiempo total
      if (tiempoTotal > 0) {
        const tiempoFormateado = formatearTiempo(tiempoTotal);
        showToast(`Simulación completada. Tiempo total: ${tiempoFormateado}`, 'success');
      }
      
    } catch (err) {
      showToast('Error en la simulación: ' + (err.message || err),'error');
      document.querySelector('.advertencias').innerHTML = '<b>Error:</b> ' + (err.message || err);
    }
  }

  // Lógica de importación de datos
  const btnCargar = document.getElementById('btn-cargar-datos');
  const fileRecetas = document.getElementById('file-recetas');
  const fileMateriales = document.getElementById('file-materiales');

  // Función toast
  function showToast(mensaje, tipo = 'info') {
    const toast = document.getElementById('toast');
    console.log('Toast:', mensaje, tipo); // Debug
    toast.textContent = mensaje;
    toast.style.display = 'block';
    toast.className = 'show';
    toast.style.background = tipo === 'success' ? '#43a047' : (tipo === 'error' ? '#c62828' : '#323232');
    toast.style.color = '#fff';
    setTimeout(() => {
      toast.className = '';
      setTimeout(()=>{toast.style.display='none';}, 400);
    }, 2600);
  }

  // Al cargar la página, NO renderizar controles ni simulación hasta que haya datos
  document.addEventListener('DOMContentLoaded', () => {
    showToast('Toast de prueba: la función está activa', 'info');
    // No renderControles ni renderSimulacion aquí
  });

  btnCargar.onclick = async () => {
    console.log('Click en btn-cargar-datos');
    showToast('Primero selecciona el archivo de RECETAS (.json), luego el de MATERIALES (.json)','info');
    fileRecetas.value = '';
    fileMateriales.value = '';
    fileRecetas.click();
  };

  fileRecetas.onchange = function(e) {
    console.log('fileRecetas.onchange');
    const file = e.target.files[0];
    if (!file) { console.log('No file en recetas'); return; }
    const reader = new FileReader();
    reader.onload = function(evt) {
      try {
        let data = JSON.parse(evt.target.result);
        if (!Array.isArray(data)) {
          showToast('El archivo de recetas debe ser un array de recetas.','error');
          return;
        }
        // Guardar en memoria como array
        estado.recetas = data;
        // Ahora pedir materiales
        fileMateriales.value = '';
        fileMateriales.click();
      } catch (err) {
        showToast('Error al importar recetas: ' + err.message, 'error');
      }
    };
    reader.readAsText(file);
  };

  fileMateriales.onchange = function(e) {
    console.log('fileMateriales.onchange');
    const file = e.target.files[0];
    if (!file) { console.log('No file en materiales'); return; }
    const reader = new FileReader();
    reader.onload = function(evt) {
      try {
        let data = JSON.parse(evt.target.result);
        if (!data.materiales || typeof data.materiales !== 'object') {
          showToast('El archivo de materiales debe tener una propiedad "materiales".','error');
          return;
        }
        // Guardar en memoria
        estado.almacenMateriales = data.materiales;
        // Contar colores por material
        let resumen = Object.entries(data.materiales).map(([nombre, colores]) => {
          let numColores = Object.values(colores).filter(v => Number(v) > 0).length;
          return `${nombre.split(':')[1]||nombre}: ${numColores} color(es)`;
        }).join(' | ');
        showToast('¡Datos importados correctamente! Ya puedes simular.\n' + resumen,'success');
        renderControles();
      } catch (err) {
        showToast('Error al importar materiales: ' + err.message, 'error');
      }
    };
    reader.readAsText(file);
  };

  document.addEventListener('DOMContentLoaded', () => {
    renderControles();
  });

  // Helper: buscar receta exacta por clase, nivel, color, equipo
  function buscarReceta(clase, nivel, color, equipo) {
    return estado.recetas.find(r => 
      r.clase === clase && 
      String(r.nivel) === String(nivel) && 
      r.color === color && 
      r.equipo === equipo
    );
  }

  // Helper: simular fabricación recursiva de un equipo
  function fabricarRecursivo(receta, inventarioActual, rutaParcial, tiempoAcumulado, visitados) {
    visitados = visitados || [];
    const recetaId = `${receta?.clase||''}|${receta?.nivel||''}|${receta?.color||''}`;
    if (visitados.includes(recetaId)) {
      advertencias.push(`Ciclo detectado: la receta ${receta?.clase||''} nivel ${receta?.nivel||''} color ${receta?.color||''} ya fue procesada en esta cadena. Recursión detenida.`);
      return { ruta: rutaParcial, inventario: inventarioActual, tiempo: tiempoAcumulado };
    }
    visitados = [...visitados, recetaId];
    if (!receta) {
      advertencias.push('Falta receta para algún paso.');
      return { ruta: rutaParcial, inventario: inventarioActual, tiempo: tiempoAcumulado };
    }
    
    // Si la receta requiere una base, fabricar la base primero
    if (receta.base && receta.base.clase && receta.base.nivel && receta.base.color && receta.base.equipo) {
      const recetaBase = buscarReceta(receta.base.clase, receta.base.nivel, receta.base.color, receta.base.equipo);
      if (!recetaBase) {
        advertencias.push(`Falta receta base: ${receta.base.equipo} ${receta.base.clase} nivel ${receta.base.nivel} color ${receta.base.color}`);
      } else {
        const resBase = fabricarRecursivo(recetaBase, inventarioActual, rutaParcial, tiempoAcumulado, visitados);
        if (!resBase || typeof resBase !== 'object') {
          advertencias.push('Error al fabricar la base: resultado inválido.');
          return { ruta: rutaParcial, inventario: inventarioActual, tiempo: tiempoAcumulado };
        }
        inventarioActual = resBase.inventario;
        rutaParcial = resBase.ruta;
        tiempoAcumulado = resBase.tiempo;
      }
    }
    
    // Procesar materiales de la receta actual
    let paso = { paso: rutaParcial.length+1, descripcion: `Fabricar ${receta.equipo||''} ${receta.clase} ${receta.color} de nivel ${receta.nivel}`, materiales: [], tiempo: 0, bifurcacion: false };
    let tiempoPaso = 0;
    let exito = true;
    
    // Obtener materiales del equipo
    const materialesEquipo = estado.materialesData[receta.clase]?.[receta.equipo] || estado.materialesData['Normal']?.[receta.equipo] || [];
    console.log('Debug - materialesEquipo:', materialesEquipo, 'para receta:', receta);
    let matIdx = 0;
    
    for (const [matColor, cantidad] of Object.entries(receta.materiales)) {
      if (!cantidad || cantidad <= 0) continue;
      for (let i = 0; i < cantidad; i++) {
        const matName = materialesEquipo[matIdx % materialesEquipo.length] || 'Material desconocido';
        const key = `Normal:${matName}`;
        console.log('Debug - matName:', matName, 'key:', key, 'matIdx:', matIdx);
        // Asegurar que el inventario tenga la estructura correcta
        if (!inventarioActual[key]) {
          inventarioActual[key] = { dorado: 0, morado: 0, azul: 0, verde: 0, blanco: 0 };
        }
        let disponible = inventarioActual[key][matColor] ? parseInt(inventarioActual[key][matColor]) : 0;
        let usado = Math.min(disponible, 1);
        inventarioActual[key][matColor] = disponible - usado;
        let faltan = 1 - usado;
        let ordenColores = ["blanco","verde","azul","morado","dorado"];
        let idxColor = ordenColores.indexOf(matColor);
        let conversiones = [];
        let convertido = 0;
        while (faltan > 0 && idxColor > 0) {
          let colorInferior = ordenColores[idxColor-1];
          let reqInferior = faltan * 4;
          let dispInferior = inventarioActual[key][colorInferior] ? parseInt(inventarioActual[key][colorInferior]) : 0;
          let puedeConvertir = Math.floor(dispInferior / 4);
          let convierte = Math.min(puedeConvertir, faltan);
          if (convierte > 0) {
            inventarioActual[key][colorInferior] -= convierte*4;
            inventarioActual[key][matColor] = (inventarioActual[key][matColor]||0) + convierte;
            conversiones.push(`Convertidos ${convierte*4} ${colorInferior} → ${convierte} ${matColor}`);
            faltan -= convierte;
            convertido += convierte;
          }
          idxColor--;
        }
        if (faltan > 0) {
          exito = false;
          paso.materiales.push(`${matName}: Falta 1 de color ${matColor}`);
        } else {
          paso.materiales.push(`${matName}: 1 ${matColor}`);
        }
        const tiempos = { dorado: 512, morado: 128, azul: 32, verde: 8, blanco: 2 };
        tiempoPaso += (tiempos[matColor] || 0);
        matIdx++;
      }
    }
    paso.tiempo = tiempoPaso;
    // Solo mostrar bifurcación si es nivel 5 y color morado/dorado
    if (parseInt(receta.nivel) === 5 && (receta.color === 'morado' || receta.color === 'dorado') && receta.porcentaje && parseFloat(receta.porcentaje) < 100) {
      paso.bifurcacion = true;
    }
    rutaParcial.push(paso);
    tiempoAcumulado += tiempoPaso;
    return { ruta: rutaParcial, inventario: inventarioActual, tiempo: tiempoAcumulado };
  }



  // Variables globales para la simulación
  let rutas = [];
  let advertencias = [];
  </script>
</body>
</html> 